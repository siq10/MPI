  void FLOODING_ST(graph G,int pi, int pr, int parent, int[] neighbors, int[] children, int[] others)
  {
    int terminate =0;
    int childrenIndex = 0, otherIndex=0;
    int status = -1;
    while(1==1)
    {
      switch (status) {
        case -1:
        {
          if(pi==pr && parent==NULL)
          {
            parent = pi;
            send("<M>",neighbors);
            break;
          }
        }
        case 1: //message from pj
        {
          if(parent==NULL)
          {
            parent = pj;
            send("<M>",neighbors);
          }
          else
          send("<already>",pj);
          break;
        }
        case 2: //parent from pj
        {
          children[childrenIndex] = pj;
          childrenIndex+=1;
          if(ContainsAllNeighborsExceptParent(children,neighbors,others,parent,childrenIndex,otherIndex, nCount))
          {
            terminate = 1;
          }
          break;
        }
        case 3: //already from pj
        {
          others[otherIndex] = pj
          otherIndex+=1;
          if(ContainsAllNeighborsExceptParent(children,neighbors,others,parent,childrenIndex,otherIndex, nCount))
          {
            terminate=1;
          }
          break;
        }
      }
      if (terminate ==1)
      break;
    }
    printf("I am the process with rank %d, I hereby state that my parent is %d",my_rank,parent);
    if(my_rank==0)
    {
      int graph[p][p];
      memset(*graph,0,sizeof(int)*p*p);
      for(int i =1;i<p;i++)
      {
        recv(i,msg);
        graph[msg][++graph[msg][0]] = i;
      }

      for (int i=0;i<p;i++)
      {
        printf("Node %d has %d children: ",i,graph[i][0]);
        for(int j=0;j<graph[i][0];j++)
        {
          printf("%d ",graph[i][j]);
          if (j==graph[i][0] - 1)
          {
            printf("\n");
          }
        }
      }

    }
  }

  bool ContainsAllNeighborsExceptParent(int[] children, int[] neighbors, int[] others,parent, childrenIndex,otherIndex,nCount)
  {
    int continue = 0;
    for (int i = 0; i < nCount;i++)
    {
      continue = 0;
      for(int j=0;j< childrenIndex;j++)
      {
        if (neighbors[i]==children[j])
        {
          continue = 1;
          break;
        }
      }
      for (int k = 0; k < otherIndex; k++) {
        if(neighbors[i] == others[k] || continue ==1)
        {
          continue = 1;
          break;
        }
      }
      if (continue==0)
      {
        return false;
      }
    }
    return true;
  }
